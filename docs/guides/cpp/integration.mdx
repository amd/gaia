---
title: "C++ Integration Guide"
description: "Consume gaia_core in your own C++ project via FetchContent, find_package, or shared library"
icon: "puzzle-piece"
---

<Info>
  **Source Code:** [`cpp/CMakeLists.txt`](https://github.com/amd/gaia/blob/main/cpp/CMakeLists.txt) -- build configuration with install rules, export targets, and FetchContent support.
</Info>

<Note>
**Prerequisites:** Familiarity with CMake and C++17. See the [C++ Framework Overview](/guides/cpp/overview) for build instructions and the `AgentConfig` reference.
</Note>

---

## Overview

There are three ways to consume `gaia_core` in your own CMake project, listed in order of recommendation:

| Method | When to use |
|--------|------------|
| **FetchContent** | Default choice -- no install step, works everywhere |
| **find_package** | You want a system-wide install or use a package manager |
| **Shared library** | You need a `.so` / `.dll` for plugin architectures |

---

## Integration Methods

<Tabs>
  <Tab title="FetchContent (Recommended)">
    The simplest approach -- CMake downloads and builds `gaia_core` as part of your project. No install step, no system packages, no manual dependency management.

    ```cmake title="CMakeLists.txt"
    cmake_minimum_required(VERSION 3.14)
    project(my_agent LANGUAGES CXX)

    set(CMAKE_CXX_STANDARD 17)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)

    include(FetchContent)
    FetchContent_Declare(
        gaia
        GIT_REPOSITORY https://github.com/amd/gaia.git
        GIT_TAG        main
        SOURCE_SUBDIR  cpp
    )
    FetchContent_MakeAvailable(gaia)

    add_executable(my_agent main.cpp)
    target_link_libraries(my_agent PRIVATE gaia::gaia_core)
    ```

    <Note>
    When consumed as a sub-project, `GAIA_BUILD_TESTS` and `GAIA_BUILD_EXAMPLES` default to `OFF`, so you only get the library -- no test binaries or demo executables in your build tree.
    </Note>

    **That is it.** All transitive dependencies (nlohmann/json, cpp-httplib) are fetched automatically. Your `main.cpp` can `#include <gaia/agent.h>` and subclass `gaia::Agent` immediately.
  </Tab>

  <Tab title="find_package (Install)">
    Use this method when you want to install `gaia_core` once and consume it from multiple projects, or when you manage dependencies via a system package manager.

    <Steps>
      <Step title="Install nlohmann/json">
        `nlohmann/json` is a public dependency of `gaia_core` (JSON types appear in the API). Install it before building:

        <Tabs>
          <Tab title="apt (Debian/Ubuntu)">
            ```bash
            sudo apt install nlohmann-json3-dev
            ```
          </Tab>
          <Tab title="vcpkg">
            ```bash
            vcpkg install nlohmann-json
            ```
          </Tab>
          <Tab title="conan">
            ```bash
            conan install nlohmann_json/3.11.3
            ```
          </Tab>
        </Tabs>
      </Step>

      <Step title="Build and install gaia_core">
        ```bash
        cmake -B build -S cpp -DCMAKE_BUILD_TYPE=Release
        cmake --build build --config Release
        cmake --install build --prefix /usr/local
        ```

        On Windows with MSVC, specify the install prefix explicitly:
        ```bat
        cmake --install build --prefix C:\gaia_core --config Release
        ```
      </Step>

      <Step title="Consume in your project">
        ```cmake title="CMakeLists.txt"
        cmake_minimum_required(VERSION 3.14)
        project(my_agent LANGUAGES CXX)

        set(CMAKE_CXX_STANDARD 17)
        set(CMAKE_CXX_STANDARD_REQUIRED ON)

        find_package(gaia_core REQUIRED)

        add_executable(my_agent main.cpp)
        target_link_libraries(my_agent PRIVATE gaia::gaia_core)
        ```

        If you installed to a non-standard prefix, pass it at configure time:
        ```bash
        cmake -B build -DCMAKE_PREFIX_PATH=/usr/local
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Shared Library (DLL)">
    Build `gaia_core` as a shared library for plugin architectures or language bindings:

    ```bash
    cmake -B build -S cpp -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release
    cmake --build build --config Release
    ```

    This produces:
    - **Linux:** `libgaia_core.so`
    - **macOS:** `libgaia_core.dylib`
    - **Windows:** `gaia_core.dll` + `gaia_core.lib` (import library)

    <Warning>
    **STL types in the public API.** `std::string`, `std::vector`, `std::function`, and `std::map` appear in the `gaia_core` public headers. On MSVC, the DLL and **all consumers** must be built with the **same compiler version and CRT runtime** (`/MD` or `/MT`). Mixing runtimes or compiler versions across the DLL boundary causes crashes and undefined behavior. Use the same toolchain (Visual Studio version, platform toolset, runtime library setting) for both the DLL and your consumer project.
    </Warning>

    Consumer `CMakeLists.txt` is identical to the `find_package` method -- the installed config handles shared vs. static automatically.
  </Tab>
</Tabs>

---

## Subclassing Example

Here is a complete minimal agent that registers one tool and processes a query. This works with any of the three integration methods above.

```cpp title="time_agent.cpp"
#include <chrono>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

#include <gaia/agent.h>
#include <gaia/types.h>

/// A minimal custom agent with one tool.
class TimeAgent : public gaia::Agent {
public:
    TimeAgent() : Agent(makeConfig()) {
        init();  // triggers registerTools() and composes system prompt
    }

protected:
    std::string getSystemPrompt() const override {
        return "You are a helpful assistant that can tell the current time. "
               "Use the get_current_time tool when the user asks about the time.";
    }

    void registerTools() override {
        toolRegistry().registerTool(
            "get_current_time",
            "Return the current local date and time as an ISO 8601 string.",
            [](const gaia::json& /*args*/) -> gaia::json {
                auto now = std::chrono::system_clock::now();
                auto time = std::chrono::system_clock::to_time_t(now);
                std::tm tm_buf{};
#ifdef _WIN32
                localtime_s(&tm_buf, &time);
#else
                localtime_r(&time, &tm_buf);
#endif
                std::ostringstream oss;
                oss << std::put_time(&tm_buf, "%Y-%m-%dT%H:%M:%S");
                return {{"current_time", oss.str()}};
            },
            {
                // This tool takes no parameters, but you could add them:
                // {"timezone", gaia::ToolParamType::STRING, false, "IANA timezone"}
            }
        );
    }

private:
    static gaia::AgentConfig makeConfig() {
        gaia::AgentConfig cfg;
        cfg.baseUrl = "http://localhost:8000/api/v1";
        cfg.modelId = "Qwen3-4B-GGUF";
        cfg.maxSteps = 10;
        return cfg;
    }
};

int main() {
    try {
        TimeAgent agent;
        auto result = agent.processQuery("What time is it right now?");

        if (result.contains("result")) {
            std::cout << result["result"].get<std::string>() << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
```

Add it to your `CMakeLists.txt`:

```cmake
add_executable(time_agent time_agent.cpp)
target_link_libraries(time_agent PRIVATE gaia::gaia_core)
```

---

## DLL Export Macros

All public classes and functions in `gaia_core` are annotated with the `GAIA_API` macro, which is generated automatically by CMake's `GenerateExportHeader`. When building as a shared library:

- **Windows (MSVC):** `GAIA_API` expands to `__declspec(dllexport)` when building the library, and `__declspec(dllimport)` when consuming it.
- **Linux / macOS:** `GAIA_API` expands to `__attribute__((visibility("default")))`.
- **Static library:** `GAIA_API` expands to nothing.

No manual annotation is needed in consumer code. Linking against the `gaia::gaia_core` CMake target sets all required compile definitions automatically.

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="FetchContent is slow on first build">
    The first configure downloads nlohmann/json, cpp-httplib, and (if tests are on) Google Test from GitHub. Subsequent builds use the CMake cache. To speed up repeated clean builds, consider using a local clone or a CMake dependency cache.
  </Accordion>

  <Accordion title="find_package cannot find gaia_core">
    Ensure you ran `cmake --install` and that the install prefix is in your `CMAKE_PREFIX_PATH`:
    ```bash
    cmake -B build -DCMAKE_PREFIX_PATH=/path/to/gaia_core/install
    ```
  </Accordion>

  <Accordion title="Linker errors with nlohmann/json on find_package">
    `nlohmann/json` is a public dependency. When using `find_package(gaia_core)`, the installed config file calls `find_dependency(nlohmann_json)`. Make sure nlohmann/json is installed system-wide (see the install steps above).
  </Accordion>

  <Accordion title="DLL crashes on Windows">
    Verify that your consumer project uses the same MSVC version, platform toolset, and CRT runtime (`/MD` vs `/MT`) as the `gaia_core` DLL. Mismatched runtimes corrupt the heap when STL objects cross the DLL boundary.
  </Accordion>
</AccordionGroup>

---

## Next Steps

<CardGroup cols={2}>
  <Card title="C++ Framework Overview" icon="code" href="/guides/cpp/overview">
    Prerequisites, AgentConfig reference, and the full project structure
  </Card>

  <Card title="C++ Source Code" icon="github" href="https://github.com/amd/gaia/tree/main/cpp">
    Browse the implementation on GitHub
  </Card>

  <Card title="Customizing Your Agent" icon="sliders" href="/guides/cpp/custom-agent">
    Custom prompts, typed tools, MCP servers, output capture, and AgentConfig tuning
  </Card>

  <Card title="Wi-Fi Troubleshooter Agent" icon="wifi" href="/guides/cpp/wifi-agent">
    Full network diagnostic and auto-fix using only registered C++ tools â€” no Python, no MCP
  </Card>

  <Card title="MCP Client Guide" icon="plug" href="/guides/mcp/client">
    How MCP client-server integration works in GAIA
  </Card>

  <Card title="Python Quickstart" icon="rocket" href="/quickstart">
    Full-featured Python framework with specialized agents, RAG, audio, and more
  </Card>
</CardGroup>

---

<small style="color: #666;">

**License**

Copyright(C) 2025-2026 Advanced Micro Devices, Inc. All rights reserved.

SPDX-License-Identifier: MIT

</small>
